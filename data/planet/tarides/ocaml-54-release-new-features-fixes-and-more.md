---
title: 'OCaml 5.4 Release: New Features, Fixes, and More!'
description: An overview of the OCaml 5.4 update highlighting new features and bug
  fixes!
url: https://tarides.com/blog/2025-10-10-ocaml-5-4-release-new-features-fixes-and-more
date: 2025-10-10T00:00:00-00:00
preview_image: https://tarides.com/blog/images/54-update-1360w.webp
authors:
- Tarides
source:
---

<p>It's everyone's favourite time of the year – the time for a new OCaml release! 5.4 brings improvements and optimisations as well as new features, some of which may be familiar to long-time members of the OCaml community. Today's post highlights some of the work done to improve the language for everyone. As always, we can't cover everything, and for a more exhaustive list, I recommend checking out the <a href="https://github.com/ocaml/ocaml/blob/5.4/Changes">changelog</a> in the OCaml repo.</p>
<p>Let's dive in!</p>
<h2>Immutable Arrays</h2>
<p>Immutable arrays, as their name suggests, are like regular arrays in OCaml, with the major difference that their contents cannot be modified after they are created. Immutability is often a useful property for data structures and extending this to arrays provides various improvements over regular arrays.</p>
<p>Immutable arrays can improve safety in cases where mutation isn't required and only random-access packed memory is needed. In such a situation, an immutable array clearly communicates the design intention to the developer, improving their use of the code and improving safety as a consequence. Since the immutability property does not allow a function to change the contents, immutable arrays also improve the reasoning properties of the code, which verification tools can use. More concretely, a new predefined type <code>'a iarray</code> and an <code>Iarray</code> module (with corresponding <code>Iarraylabels</code>) have been added to the <code>Stdlib</code>.</p>
<p>Lastly, immutable arrays can be safely coerced since there's no risk of inserting incompatible types. Consider this code example:</p>
<pre><code><span class="ocaml-keyword-other">module</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-capital-identifier">Positive</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other-ocaml punctuation-other-colon punctuation">:</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">sig</span><span class="ocaml-source">
</span><span class="ocaml-source">  </span><span class="ocaml-keyword">type</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">t</span><span class="ocaml-source"> = </span><span class="ocaml-keyword-other-ocaml">private</span><span class="ocaml-source"> int
</span><span class="ocaml-source">  </span><span class="ocaml-keyword">val</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">make</span><span class="ocaml-source"> : int -&gt; t
</span><span class="ocaml-keyword-other">end</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">struct</span><span class="ocaml-source">
</span><span class="ocaml-source">  </span><span class="ocaml-keyword-other">type</span><span class="ocaml-source"> </span><span class="ocaml-source">t</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-support-type">int</span><span class="ocaml-source">
</span><span class="ocaml-source">  </span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">make</span><span class="ocaml-source"> </span><span class="ocaml-source">i</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">if</span><span class="ocaml-source"> </span><span class="ocaml-source">i</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">&gt;</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">0</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">then</span><span class="ocaml-source"> </span><span class="ocaml-source">i</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">else</span><span class="ocaml-source"> </span><span class="ocaml-source">invalid_arg</span><span class="ocaml-source"> </span><span class="ocaml-string-quoted-double">"</span><span class="ocaml-string-quoted-double">make</span><span class="ocaml-string-quoted-double">"</span><span class="ocaml-source">
</span><span class="ocaml-keyword-other">end</span><span class="ocaml-source">
</span><span class="ocaml-source">
</span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">nums</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-source">[</span><span class="ocaml-constant-numeric-decimal-integer">1</span><span class="ocaml-keyword-other-ocaml punctuation-separator-terminator punctuation-separator">;</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">2</span><span class="ocaml-keyword-other-ocaml punctuation-separator-terminator punctuation-separator">;</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">3</span><span class="ocaml-keyword-other-ocaml punctuation-separator-terminator punctuation-separator">;</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">4</span><span class="ocaml-keyword-other-ocaml punctuation-separator-terminator punctuation-separator">;</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">5</span><span class="ocaml-keyword-other-ocaml punctuation-separator-terminator punctuation-separator">;</span><span class="ocaml-source"> </span><span class="ocaml-constant-numeric-decimal-integer">6</span><span class="ocaml-source">]</span><span class="ocaml-source">
</span><span class="ocaml-source">
</span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">lst</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-capital-identifier">List</span><span class="ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator">.</span><span class="ocaml-source">map</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-capital-identifier">Positive</span><span class="ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator">.</span><span class="ocaml-source">make</span><span class="ocaml-source"> </span><span class="ocaml-source">nums</span><span class="ocaml-source">
</span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">arr</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-capital-identifier">Array</span><span class="ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator">.</span><span class="ocaml-source">of_list</span><span class="ocaml-source"> </span><span class="ocaml-source">lst</span><span class="ocaml-source">
</span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">iarr</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-constant-language-capital-identifier">Iarray</span><span class="ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator">.</span><span class="ocaml-source">of_list</span><span class="ocaml-source"> </span><span class="ocaml-source">lst</span><span class="ocaml-source">
</span></code></pre>
<p>You can sum up <code>lst</code> with <code>List.fold_left (+) 0 (lst :&gt; int list)</code>, but if you do that with <code>Array.fold_left (+) 0 (arr :&gt; int array)</code> you will be told <code>Type Positive.t array is not a subtype of int array</code>. Conversely, <code>Iarray.fold_left (+) 0 (iarr :&gt; int iarray)</code> works, which is very useful, as the only workaround with an array is to coerce individually or - more often - copy the items to a new array, which is unfortunate (because the copy is just to satisfy type safety).</p>
<p>Pull Request <a href="https://github.com/ocaml/ocaml/pull/13097">#13097</a> introduced immutable arrays to OCaml 5. It is a feature <a href="https://www.janestreet.com/">Jane Street</a> has been using internally in their <a href="https://github.com/tarides/tarides.com/pull/oxcaml.org">OxCaml branch</a>.  The team at Tarides collaborated with Jane Street engineers to upstream this feature. The resulting PR sparked some great discussions in the community, and after considering their feedback, it was merged to form part of the 5.4 release.</p>
<h2>Labelled Tuples</h2>
<p>Labelled tuples allow the developer to label tuple elements, giving useful names to constructed values in cases where labelled function arguments allow them to name parameters. Reordered and partial patterns are resolved during type checking, and the labels are erased during translation to lambda. Labelled tuples do not support extracting an element of the tuple by the label.</p>
<p>One example of this being useful is when developers want to compute two values from a list without mixing them up. Labelled tuples can help prevent them from accidentally returning the pair in the wrong order or mixing up the order of the initial values. This code was given as a motivating example by the authors:</p>
<pre><code><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">sum_and_product</span><span class="ocaml-source"> </span><span class="ocaml-source">ints</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source">
</span><span class="ocaml-source">  </span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">init</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> ~</span><span class="ocaml-source">sum</span><span class="ocaml-keyword-other-ocaml punctuation-other-colon punctuation">:</span><span class="ocaml-constant-numeric-decimal-integer">0</span><span class="ocaml-keyword-other-ocaml punctuation-comma punctuation-separator">,</span><span class="ocaml-source"> ~</span><span class="ocaml-source">product</span><span class="ocaml-keyword-other-ocaml punctuation-other-colon punctuation">:</span><span class="ocaml-constant-numeric-decimal-integer">1</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">in</span><span class="ocaml-source">
</span><span class="ocaml-source">  </span><span class="ocaml-constant-language-capital-identifier">List</span><span class="ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator">.</span><span class="ocaml-source">fold_left</span><span class="ocaml-source"> </span><span class="ocaml-source">ints</span><span class="ocaml-source"> ~</span><span class="ocaml-source">init</span><span class="ocaml-source">
</span><span class="ocaml-source">    ~</span><span class="ocaml-source">f</span><span class="ocaml-keyword-other-ocaml punctuation-other-colon punctuation">:</span><span class="ocaml-source">(</span><span class="ocaml-keyword-other">fun</span><span class="ocaml-source"> </span><span class="ocaml-source">(</span><span class="ocaml-source">~</span><span class="ocaml-source">sum</span><span class="ocaml-keyword-other-ocaml punctuation-comma punctuation-separator">,</span><span class="ocaml-source"> ~</span><span class="ocaml-source">product</span><span class="ocaml-source">)</span><span class="ocaml-source"> </span><span class="ocaml-source">elem</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">-&gt;</span><span class="ocaml-source">
</span><span class="ocaml-source">          </span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">sum</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-source">elem</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">+</span><span class="ocaml-source"> </span><span class="ocaml-source">sum</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">in</span><span class="ocaml-source">
</span><span class="ocaml-source">          </span><span class="ocaml-keyword">let</span><span class="ocaml-source"> </span><span class="ocaml-entity-name-function-binding">product</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">=</span><span class="ocaml-source"> </span><span class="ocaml-source">elem</span><span class="ocaml-source"> </span><span class="ocaml-keyword-operator">*</span><span class="ocaml-source"> </span><span class="ocaml-source">product</span><span class="ocaml-source"> </span><span class="ocaml-keyword-other">in</span><span class="ocaml-source">
</span><span class="ocaml-source">          ~</span><span class="ocaml-source">sum</span><span class="ocaml-keyword-other-ocaml punctuation-comma punctuation-separator">,</span><span class="ocaml-source"> ~</span><span class="ocaml-source">product</span><span class="ocaml-source">)</span><span class="ocaml-source">
</span></code></pre>
<p>The function <code>~f</code> has type <code>sum:int * product:int -&gt; int -&gt; sum:int * product:int</code> which enforces the ordering when constructing the return tuple.</p>
<p>Jane Street has been using labelled tuples internally for almost a year as part of their <a href="https://oxcaml.org/documentation/miscellaneous-extensions/labeled-tuples/">OxCaml branch</a>, and reports that it has been a useful and popular feature. A core developer, David Allsopp, also benefited from it when he was working on the Relocatable OCaml Project. He used labelled tuples in the <a href="https://github.com/ocaml/ocaml/pull/14014/files#diff-74b2bd0c4072976502190e79aa388834d77bb7311de8a517ff13d6fc464a0012R159">test harness</a> for the feature.</p>
<p>To find out more, check out Chris's <a href="https://www.youtube.com/live/KLWiEf3x3kc?si=TLHVrsMNz72T63JT&amp;t=25505">talk from the 2024 ML workshop</a>, <a href="https://tyconmismatch.com/papers/ml2024_labeled_tuples.pdf">the ML workshop talk proposal</a>, and <a href="https://github.com/ocaml/ocaml/pull/13498">PR #13498</a>, which documents the changes.</p>
<h2>Frame Pointers</h2>
<p>Frame pointers are used to <em>walk the stack</em> of function calls in a program. Tools like profilers and debuggers use frame pointers to walk the stack and reconstruct the call graph for programs. Having this support means that third-party debugging and performance tools, like perf, eBPF, Dtrace, GDB, and LLDB now work much better with OCaml.</p>
<p>The history of frame pointers in OCaml is a long and somewhat complicated one. The compiler has had an option for frame pointers on AMD64 since OCaml 4.01, released in 2013. After the multicore update in OCaml 5, support returned for Linux/AMD64 (<a href="https://github.com/ocaml/ocaml/pull/11144">#11144</a>) in the 5.1 release and macOS/AMD64(<a href="https://github.com/ocaml/ocaml/pull/13163">#13163</a>) in the 5.3 release. In 5.4, support was added for ARM64 on both Linux and macOS, along with documentation on using frame pointers to profile OCaml code. The team has started work on supporting RISC-V, s390x, and Power architectures, which we hope to see implemented in the future.</p>
<p>For a fuller view of all the work, you can check out PRs <a href="https://github.com/ocaml/ocaml/issues/13500">#13500</a>, <a href="https://github.com/ocaml/ocaml/issues/13575">#13575</a>, <a href="https://github.com/ocaml/ocaml/pull/13635">#13635</a>, and <a href="https://github.com/ocaml/ocaml/pull/13751">#13751</a>, which have improved frame pointer support in OCaml 5.4. Tim McGilchrist also wrote a <a href="https://lambdafoo.com/posts/2025-02-24-ocaml-frame-pointers.html">blog post on his website</a> about implementing frame pointers in OCaml.</p>
<h2>Atomic Field Accesses</h2>
<p>Previously, OCaml 5 had limited support for atomic operations, only supporting them on the special <code>'a Atomic.t</code> type.  After a lot of discussion on the best solutions, consensus landed on introducing records with atomic fields to improve performance when implementing concurrent data structures. Instead of requiring a field to be of type <code>'a Atomic.t</code> and introduce an indirection on that record field, having records with atomic fields is more efficient.</p>
<p>PR <a href="https://github.com/ocaml/ocaml/pull/13404">#13404</a> implements atomic operations, including two features described in <a href="https://github.com/ocaml/RFCs/pull/39">'atomic record fields' RFC</a>. First, atomic record fields are now just record fields marked with an atomic attribute, and their reads and writes are compiled into atomic operations. Second, the PR implements atomic locations, a compiler-supported way to describe an atomic field within a record to perform atomic operations in addition to read and write operations.</p>
<h2>Unloadable Runtime</h2>
<p>OCaml 5.4 reintroduces 'memory cleanup upon exit' mode. The purpose of this mode is to enable something called the 'unloadable runtime'. Suppose you're running a program written in another programming language, and you use an OCaml library as a shared library. When control switches over from the OCaml library to the main program, you want the handover to happen cleanly, with all OCaml runtime resources being 'unloaded', including the stack, heap sections, code fragments, custom operations, buffers, and tables.</p>
<p>In the update from OCaml 4 to 5, support for the unloadable runtime was lost as multiple domains complicated matters. An OCaml program generally stops and exits once the main domain runs to completion, and the same behaviour needs to be adopted for multiple domains. When the main domain stops, the other domains are also terminated. Terminating all running domains was the trickiest aspect to implement since only stopping for garbage collection was originally supported. Now, with 'memory cleanup upon exit' mode, all domains can be terminated, and the runtime can be unloaded before control is handed back, ensuring a clean handover to a host program. Learn more in PR <a href="https://github.com/ocaml/ocaml/pull/12964">#12964</a>, which introduced the feature in 5.4.</p>
<h2>… And Many More!</h2>
<h3>GC Performance Improvements (Stephen Dolan, Nick Barnes, Gabriel Scherer, reviews by François Bobot, Josh Berdine, Damien Doligez, Tim McGilchrist, Guillaume Munch-Maccagnoni, benchmarking by Nicolás Ojeda Bär, and reports  by Emilio Jesús Gallego Arias and Olivier Nicole)</h3>
<p>This project improved the performance of garbage collection in the runtime. Changes to the way ephemerons are treated by the minor GC, allowing values from ephemeron keys to be collected and optimising them so they are not re-marked, have expanded their functionality whilst keeping the minor GC performant. A change to the major GC’s pacing, fixing a bug where the <code>work_counter</code> would get out of sync with the <code>alloc_counter</code>, also boosted performance. Finally, a new <code>Gc.ramp_up</code> callback will be introduced, allowing users to mark ramp-up phases of memory consumption and preventing slowdowns as a result of collection work being done twice. The work is spread across several PRs, including <a href="https://github.com/ocaml/ocaml/pull/13643">#13643</a>, <a href="https://github.com/ocaml/ocaml/pull/13827">#13827</a>, <a href="https://github.com/ocaml/ocaml/pull/13736">#13736</a>, <a href="https://github.com/ocaml/ocaml/issues/13300">#13300</a>, and  <a href="https://github.com/ocaml/ocaml/pull/13861">#13861</a>.</p>
<h3>Software Prefetching Support (Tim McGilchrist, review by Nick Barnes, Antonin Décimo, Stephen Dolan and Miod Vallat)</h3>
<p>5.4 enables software prefetching instructions for several architectures, including ARM64, s390x, PPC64, and RISC-V. This feature advises the processor to 'pre-fetch' data from slower memory and store it in faster memory before it is needed. This can help improve the overall performance of programs, and in fact, the PR <a href="https://github.com/ocaml/ocaml/pull/13582">#13582</a> contains several benchmarks showing speed-ups as a result of the changes.</p>
<h3>Review of Locking in the Multicore Runtime (Guillaume Munch-Maccagnoni, review by Gabriel Scherer, tests by Jan Midtgaard)</h3>
<p>Part of the task between updates is to identify and address problems. In PRs <a href="https://github.com/ocaml/ocaml/pull/13227">#13227</a> and <a href="https://github.com/ocaml/ocaml/pull/13714">#13714</a>, issues surrounding the <code>caml_plat_lock_non_blocking</code> and <code>caml_plat_lock_blocking</code> caused deadlocks in the runtime. After auditing and testing the code to see what was going wrong, tighter constraints about when and how the commands could be mixed helped solve the deadlocking.</p>
<h2>A Few Bug Fixes</h2>
<h3><a href="https://github.com/ocaml/ocaml/pull/13605">#13605</a> (Samuel Vivien, review by Florian Angeletti, Richard Eisenberg and Jacques Garrigue)</h3>
<p>This PR adds a check to detect and prevent errors occurring as a result of generating typing constraints. When users define a parametrised type and create a constraint by binding that type with an <code>as</code>, there were times when a constraint would not behave as expected. By adding an error, this PR prevents users from having constraints and introduces unwanted behaviour.</p>
<h3><a href="https://github.com/ocaml/ocaml/pull/13812">#13812</a> (Samuel Vivien, review by Gabriel Scherer)</h3>
<p>This PR adds another check that tests the validity of the type variable name on the right-hand side of <code>_as_</code>. The added test reduces friction and confusion for the user.</p>
<h3><a href="https://github.com/ocaml/ocaml/pull/13895">#13895</a> and <a href="https://github.com/ocaml/ocaml/pull/13691">#13691</a> (Jan Midtgaard, review by Miod Vallat, Sadiq Jaffer and Antonin Décimo)</h3>
<p>Gc.control had four underlying globals that would cause data races when tested with <a href="https://ocaml.org/manual/5.3/tsan.html">TSan</a>. Jan tested them and rewrote them to be atomic, which resolved the racing and brought them in line with other globals which were already atomic.</p>
<h2>What’s Next?</h2>
<p>Work continues! Performance improvements to the garbage collector that aim to reduce the performance gap between versions 4.14 and 5.x include GC pacing and mark delay work.  Relocatable OCaml is another ongoing project, whose <a href="https://github.com/ocaml/RFCs/pull/53">RFC</a> was accepted in principle in March. It wasn't quite ready for 5.4, but will hopefully <a href="https://icfp22.sigplan.org/details/ocaml-2022-papers/12/Copying-opam-switches-it-should-Just-Work-">finally be arriving</a> in OCaml 5.5!</p>
<p>You can connect with us on <a href="https://bsky.app/profile/tarides.com">Bluesky</a>, <a href="https://mastodon.social/@tarides">Mastodon</a>, <a href="https://www.threads.net/@taridesltd">Threads</a>, and <a href="https://www.linkedin.com/company/tarides">LinkedIn</a> or sign up for our mailing list to stay updated on our latest projects. We look forward to hearing from you!</p>

